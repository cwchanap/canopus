//! Schema generation utilities

use anyhow::{Context, Result};
use schema::{ClientConfig, DaemonConfig, Event, Message, Response, SystemState};
use schemars::schema_for;
use std::fs;
use std::path::Path;

/// Generate JSON schemas and TypeScript definitions
pub(crate) fn run() -> Result<()> {
    println!("Generating schemas...");

    // Create schemas directory
    let schemas_dir = Path::new("schemas");
    fs::create_dir_all(schemas_dir).context("Failed to create schemas directory")?;

    // Generate JSON schemas
    generate_json_schemas(schemas_dir)?;

    // Generate TypeScript definitions
    generate_typescript_definitions(schemas_dir)?;

    println!("✓ Schema generation complete");
    Ok(())
}

fn generate_json_schemas(schemas_dir: &Path) -> Result<()> {
    println!("  Generating JSON schemas...");

    let schemas = [
        ("Message", schema_for!(Message)),
        ("Response", schema_for!(Response)),
        ("DaemonConfig", schema_for!(DaemonConfig)),
        ("ClientConfig", schema_for!(ClientConfig)),
        ("Event", schema_for!(Event)),
        ("SystemState", schema_for!(SystemState)),
    ];

    for (name, schema) in schemas {
        let json = serde_json::to_string_pretty(&schema)
            .context(format!("Failed to serialize {} schema", name))?;

        let filename = format!("{}.json", name);
        let path = schemas_dir.join(&filename);

        fs::write(&path, json).context(format!("Failed to write {}", filename))?;

        println!("    ✓ Generated {}", filename);
    }

    Ok(())
}

fn generate_typescript_definitions(schemas_dir: &Path) -> Result<()> {
    println!("  Generating TypeScript definitions...");

    let ts_dir = schemas_dir.join("ts");
    fs::create_dir_all(&ts_dir).context("Failed to create TypeScript directory")?;

    let mut typescript_content = String::new();
    typescript_content.push_str("// Auto-generated TypeScript definitions for Canopus schemas\n");
    typescript_content.push_str("// Do not edit this file manually\n\n");

    // Add Message type
    typescript_content.push_str("export type Message = \n");
    typescript_content.push_str("  | { type: 'Status' }\n");
    typescript_content.push_str("  | { type: 'Start' }\n");
    typescript_content.push_str("  | { type: 'Stop' }\n");
    typescript_content.push_str("  | { type: 'Restart' }\n");
    typescript_content.push_str("  | { type: 'Custom'; command: string };\n\n");

    // Add Response type
    typescript_content.push_str("export type Response = \n");
    typescript_content.push_str("  | { type: 'Ok'; message: string }\n");
    typescript_content.push_str("  | { type: 'Error'; message: string; code?: string }\n");
    typescript_content.push_str(
        "  | { type: 'Status'; running: boolean; uptimeSeconds: number; version?: string };\n\n",
    );

    // Add DaemonConfig type
    typescript_content.push_str("export interface DaemonConfig {\n");
    typescript_content.push_str("  host: string;\n");
    typescript_content.push_str("  port: number;\n");
    typescript_content.push_str("  logLevel: string;\n");
    typescript_content.push_str("  maxConnections: number;\n");
    typescript_content.push_str("}\n\n");

    // Add ClientConfig type
    typescript_content.push_str("export interface ClientConfig {\n");
    typescript_content.push_str("  daemonHost: string;\n");
    typescript_content.push_str("  daemonPort: number;\n");
    typescript_content.push_str("  timeoutSeconds: number;\n");
    typescript_content.push_str("}\n\n");

    // Add Event type
    typescript_content.push_str("export type Event = \n");
    typescript_content
        .push_str("  | { type: 'DaemonStarted'; timestamp: string; version: string }\n");
    typescript_content.push_str("  | { type: 'DaemonStopped'; timestamp: string }\n");
    typescript_content
        .push_str("  | { type: 'ClientConnected'; timestamp: string; clientId: string }\n");
    typescript_content
        .push_str("  | { type: 'ClientDisconnected'; timestamp: string; clientId: string }\n");
    typescript_content
        .push_str("  | { type: 'Custom'; eventType: string; timestamp: string; data: any };\n\n");

    // Add SystemState type
    typescript_content.push_str("export interface SystemState {\n");
    typescript_content.push_str("  daemonRunning: boolean;\n");
    typescript_content.push_str("  activeConnections: number;\n");
    typescript_content.push_str("  uptimeSeconds: number;\n");
    typescript_content.push_str("  version: string;\n");
    typescript_content.push_str("  lastUpdated: string;\n");
    typescript_content.push_str("}\n");

    let ts_path = ts_dir.join("index.d.ts");
    fs::write(&ts_path, typescript_content).context("Failed to write TypeScript definitions")?;

    println!("    ✓ Generated index.d.ts");
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_schema_generation() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let schemas_dir = temp_dir.path().join("schemas");

        fs::create_dir_all(&schemas_dir)?;
        generate_json_schemas(&schemas_dir)?;

        // Check that files were created
        assert!(schemas_dir.join("Message.json").exists());
        assert!(schemas_dir.join("Response.json").exists());
        assert!(schemas_dir.join("DaemonConfig.json").exists());

        Ok(())
    }

    #[test]
    fn test_typescript_generation() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let schemas_dir = temp_dir.path().join("schemas");

        fs::create_dir_all(&schemas_dir)?;
        generate_typescript_definitions(&schemas_dir)?;

        // Check that TypeScript file was created
        let ts_file = schemas_dir.join("ts").join("index.d.ts");
        assert!(ts_file.exists());

        let content = fs::read_to_string(ts_file)?;
        assert!(content.contains("export type Message"));
        assert!(content.contains("export type Response"));

        Ok(())
    }
}
